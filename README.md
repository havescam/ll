1. Задание 18. Жадный алгоритм: максимальное независимое множество
Условие. В графе найти максимальное по размеру независимое множество вершин (никакие
две не смежны).
Алгоритм: жадный выбор вершины минимальной степени.
Язык примера: Java
public static Set<Integer> maxIndependentSet(int[][] adjMatrix) {
 int n = adjMatrix.length;
 boolean[] deleted = new boolean[n];
 Set<Integer> result = new HashSet<>();
 while (true) {
 int v = -1;
 // ДОПИСАТЬ: найти вершину с минимальной степенью среди не удалённой
 if (v == -1) break;
 result.add(v); // Удалить v и всех её соседей
 deleted[v] = true;
 for (int u = 0; u < n; u++) {
 if (adjMatrix[v][u] == 1) deleted[u] = true;
 }
 }
 return result;
}
Что дописать: цикл по вершинам для поиска v с минимумом соседей.

2. Описание алгоритма:
Шаг 1: Инициализация структур — n = число вершин, deleted[0..n-1]=false, result=∅; работаем до тех пор, пока найдётся не удалённая вершина.​

Шаг 2: Поиск v — выбираем среди не удалённых вершину минимальной степени d(v); при равенстве можно взять любую.​

Шаг 3: Добавление — кладём v в result, так как с ранее выбранными она не смежна по инварианту алгоритма.​

Шаг 4: Удаление — помечаем v и всех её соседей N(v) как удалённых, чтобы далее сохранялась независимость.​

Шаг 5: Повтор — продолжаем для подграфа G \ N[v] до пустого остатка; результат максимален по включению и служит приближением к максимально‑му независимому множеству.​
Результат работы: множество вершин result, где никакие две вершины не смежны, и к нему нельзя добавить ни одной оставшейся вершины без нарушения независимости.

3. Временная сложность: O(m+n)

4. Объяснение временной сложности:
При матрице смежности на каждой итерации нужно просканировать строки, чтобы посчитать степени и удалить соседей — это O(n) на шаг и до n шагов, всего O(n^2); при списках смежности каждая вершина и каждое ребро обрабатываются константное число раз, что даёт O(m+n).

5. Ответ на контрольный вопрос. 18. NP-сложность
Почему мы используем приближенные алгоритмы для NP-сложных задач? Объясните суть
проблемы.​
Ответ: Многие оптимизационные задачи, включая максимум независимого множества, NP‑трудны, и не известно полиномиальных точных алгоритмов; получение таких алгоритмов означало бы P=NP, что считается маловероятным, поэтому применяют приближения, которые за полиномиальное время дают решение с гарантированным коэффициентом близости к оптимуму и часто хорошо работают на практических классах графов.
